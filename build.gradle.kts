import com.gtnewhorizons.retrofuturagradle.ObfuscationAttribute
import com.gtnewhorizons.retrofuturagradle.minecraft.RunMinecraftTask
import java.util.regex.Pattern

plugins {
    id("com.gtnewhorizons.gtnhconvention")
}

// workaround an OOM on GH actions during the checkStyleMain task
tasks.withType<Checkstyle>().configureEach {
    maxHeapSize = "1g"
}

tasks.test.configure {
    useJUnitPlatform()
    testLogging {
        events("passed", "skipped", "failed")
    }
}

fun parseGtVersion(versionStr: String): Triple<Int, Int, Int> {
    val components = versionStr.split(Pattern.compile("[.-]"), 5)
    val vMajor = 500 + components[1].toInt()
    val vMinor = components[2].toInt()
    val vPatch = components[3].toInt()
    return Triple(vMajor, vMinor, vPatch)
}

var gtNbtVersion: Triple<Int, Int, Int> = Triple(509, 44, 0)
var logLevel = LogLevel.INFO
try {
    val verStr = project.version.toString()
    gtNbtVersion = parseGtVersion(verStr)
} catch (_: Exception) {
    try {
        val verStr = providers.exec {
            commandLine("git", "describe")
        }.standardOutput.asText.get()
        gtNbtVersion = parseGtVersion(verStr)
        logLevel = LogLevel.LIFECYCLE
    } catch (_: Exception) {
        logger.error("Cannot automatically determine NBT version. Using defaults hardcoded in buildscript. This could break your world!")
        logLevel = LogLevel.WARN
    }
}

minecraft {
    injectedTags.put("VERSION_MAJOR", gtNbtVersion.first)
    injectedTags.put("VERSION_MINOR", gtNbtVersion.second)
    injectedTags.put("VERSION_PATCH", gtNbtVersion.third)
    logger.log(logLevel, "Using {} as NBT version", gtNbtVersion)
}

val functionalTest by sourceSets.creating {
    java {
        srcDir("src/functionalTest/java")
        compileClasspath += sourceSets.patchedMc.get().output + sourceSets.main.get().output
    }
}

configurations {
    // Keep all dependencies from the main mod in the functional test mod
    named(functionalTest.compileClasspathConfigurationName).configure {extendsFrom(configurations.compileClasspath.get())}
    named(functionalTest.runtimeClasspathConfigurationName).configure {extendsFrom(configurations.runtimeClasspath.get())}
    named(functionalTest.annotationProcessorConfigurationName).configure {extendsFrom(configurations.annotationProcessor.get())}
}

tasks.register<Jar>(functionalTest.jarTaskName) {
    archiveClassifier.set("functionalTests")
    // we don't care about the version number here, keep it stable to avoid polluting the tmp directory
    archiveVersion.set("1.0")
    destinationDirectory.set(layout.buildDirectory.dir("tmp"))
}

tasks.assemble.configure {
    dependsOn(functionalTest.jarTaskName)
}

// Run tests in the default runServer/runClient configurations
tasks.named<RunMinecraftTask>("runServer").configure {
    dependsOn(functionalTest.jarTaskName)
    classpath(configurations.named(functionalTest.runtimeClasspathConfigurationName), tasks.named(functionalTest.jarTaskName))
}

tasks.named<RunMinecraftTask>("runClient").configure {
    dependsOn(functionalTest.jarTaskName)
    classpath(configurations.named(functionalTest.runtimeClasspathConfigurationName), tasks.named(functionalTest.jarTaskName))
}

// Codegen sourceset, it's compiled and run with Java 25 before the main GT code.
// The classes generated by it are added to the built jar and accessible from the main sourceset

val codegenProject = project(":codegen")
val codegenLauncher = javaToolchains.launcherFor { languageVersion = JavaLanguageVersion.of(25) }
val codegenConfig = configurations.create("codegen")
val codegenInputDir = project.layout.projectDirectory.dir("src/main/resources/assets/gregtech/data").asFile
val codegenOutputDir = project.layout.buildDirectory.dir("generated/codegen").get().asFile

spotless.java {
    target("codegen/src/main/java/**/*.java")
}

codegenConfig.attributes.attribute(ObfuscationAttribute.OBFUSCATION_ATTRIBUTE, ObfuscationAttribute.getNoMinecraft(objects))
dependencies.add(codegenConfig.name, codegenProject)

val runGtCodegen = tasks.register<JavaExec>("runCodegen") {
    description = "Data-driven class generation step"
    group = "GregTech"

    inputs.dir(codegenInputDir)
    outputs.dir(codegenOutputDir)
    javaLauncher = codegenLauncher
    classpath = codegenConfig
    mainClass = "gt5codegen.Gt5Codegen"
    workingDir = project.projectDir

    // Use system properties to pass named arguments
    systemProperties(mapOf<String, String>(
        "gt5codegen.outputDir" to codegenOutputDir.absolutePath,
        "gt5codegen.inputDir" to codegenInputDir.absolutePath,
    ))
}

val codegennedClassesDir = runGtCodegen.map { it.outputs.files }
dependencies {
    compileOnly(codegennedClassesDir)
}
listOf(tasks.jar, tasks.shadowJar).forEach { it.configure {
    from(codegennedClassesDir)
}}

